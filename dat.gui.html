<!doctype html>
<html>

<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width" />
<title>Three | Cubes</title>
<style>
* { margin: 0; padding: 0; }
html, body, canvas { display: block; }
.stats { position: absolute; left: 0; top: 0; }
body .dg { font-family: sans-serif; text-shadow: none; }
body .dg.main { background: #000; }
body .dg.main::-webkit-scrollbar { width: 10px; border-radius: 5px; }
body .dg.a { margin-right: 0; }
body .dg .property-name { width: 15%; text-indent: 5px; }
body .dg .c { width: 85%; }
body .dg li { -webkit-transition: none; }
</style>
</head>

<body>

<script src="three-82.js"></script>
<script>
var DEG_TO_RAD = 2 * Math.PI / 360,
	RAD_TO_DEG = 1 / DEG_TO_RAD;

// set the scene size
var WIDTH = innerWidth,
    HEIGHT = innerHeight;

// set some camera attributes
var VIEW_ANGLE = 45,
    ASPECT = WIDTH / HEIGHT,
    NEAR = 1,
    FAR = 10000;

// webgl renderer
var renderMethod = '#canvas' == location.hash ? 'CanvasRenderer' : 'WebGLRenderer';
var renderer = new THREE[renderMethod]({antialias: true});
renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0));
renderer.clear();
renderer.setSize(WIDTH, HEIGHT);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// scene (= viewport?)
var scene = new THREE.Scene();

// camera
var camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
camera.position.x = 200;
camera.position.y = 500;
camera.position.z = 700;
scene.add(camera);

// point at the center
camera.lookAt(scene.position);
// for SOME reason, this changes the camera's Z axis

// ==== //

var planeMat = new THREE.MeshLambertMaterial({color: 0xFFFFFF});

// x, z
var planeGeo = new THREE.PlaneGeometry(500, 1200, 10, 10);
var plane = new THREE.Mesh(planeGeo, planeMat);
plane.rotation.x = -90 * DEG_TO_RAD;
//plane.receiveShadow = true;
scene.add(plane);

// y, z
/*var planeGeo2 = new THREE.PlaneGeometry(1200, 500, 10, 10);
var plane2 = new THREE.Mesh(planeGeo2, planeMat);
plane2.rotation.y = 90 * DEG_TO_RAD;
plane2.position.x = -240;
plane2.position.y = 240;
scene.add(plane2);*/

// ==== //

// create material
var material = new THREE.MeshLambertMaterial({color: 0xCC0000});

// create geometry
var geo = new THREE.CubeGeometry(50, 100, 200);

// create cube
var cube1 = new THREE.Mesh(geo, material);
cube1.custom = {};
cube1.custom.I = 0;
cube1.custom.name = 'The red beam';
//cube1.castShadow = true;
//cube1.receiveShadow = true;
cube1.position.x = 0;
cube1.position.y = 50;
scene.add(cube1);

// ==== //

// create material
var material = new THREE.MeshLambertMaterial({color: 0x0000FF});

// create geometry
var geo = new THREE.CubeGeometry(100, 100, 100);

// create cube
var cube2 = new THREE.Mesh(geo, material);
cube2.custom = {};
cube2.custom.I = 0;
cube2.custom.name = 'The blue cube';
//cube2.castShadow = true;
//cube2.receiveShadow = true;
cube2.position.x = 75;
cube2.position.y = 50;
scene.add(cube2);

// ==== //

// create a point light
var pointLight = new THREE.PointLight(0xFFFF88);
//pointLight.castShadow = true;
pointLight.position.x = 0;
pointLight.position.y = 250;
pointLight.position.z = 550;
scene.add(pointLight);

// create a point light
var pointLight2 = new THREE.PointLight(0x88FFFF);
//pointLight2.castShadow = true;
pointLight2.position.x = 0;
pointLight2.position.y = 250;
pointLight2.position.z = -450;
scene.add(pointLight2);

// ==== //

function v(x,y,z){
	return new THREE.Vector3(new THREE.Vector3(x,y,z));
}

var lineGeo = new THREE.Geometry();
lineGeo.vertices.push(
	v(-1500, 0, 0), v(1500, 0, 0),
	v(0, -1500, 0), v(0, 1500, 0),
	v(0, 0, -1500), v(0, 0, 1500)
);
var lineMat = new THREE.LineBasicMaterial({
	color: 0x888888,
	linewidth: 1
});
var line = new THREE.Line(lineGeo, lineMat);
line.type = THREE.Lines;
scene.add(line);

// ==== //

var paused, I = 0
function rotate() {
	var rad, x, y, z

	rad = ++I * DEG_TO_RAD
	x = 500 * Math.sin(rad)
	z = 500 * Math.cos(rad)

	camera.position.x = x
	camera.position.z = z
	camera.lookAt(scene.position)
}

// ==== //

function render(t) {
	renderer.render(scene, camera);
	!paused && rotate();

	window.stats && stats.update();

	requestAnimationFrame(render);
}

render();

// ==== //

document.addEventListener('click', function(e) {
	paused = !paused;
});
</script>

<script src="Stats.js"></script>
<script src="dat.gui.js"></script>
<script>
var stats = new Stats();
stats.getDomElement().className += ' stats';
document.body.appendChild(stats.getDomElement());

var gui = new dat.GUI(), fl;

fl = gui.addFolder('camera.rotation');
fl.add(camera.rotation, 'x', -5, 5, 0.1).listen();
fl.add(camera.rotation, 'y', -5, 5, 0.1).listen();
fl.add(camera.rotation, 'z', -5, 5, 0.1).listen();
fl.open();

fl = gui.addFolder('camera.position');
fl.add(camera.position, 'x', -2500, 2500, 10).listen();
fl.add(camera.position, 'y', -2500, 2500, 10).listen();
fl.add(camera.position, 'z', -2500, 2500, 10).listen();
fl.open();
</script>

</body>

</html>
